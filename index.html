<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GTM Playground</title>
  <!-- Application version metadata.  Update these values when you commit new versions.
       app-version holds a simple version string, e.g. 1.2.3, and app-changelog holds
       a short description of what changed. -->
  <meta name="app-version" content="3.3.0">
  <meta name="app-changelog" content="Add warning when local changes">
  <style>
    /*
     * Base layout styling.  A subtle background colour and modern
     * typography give the app a more contemporary feel.  The
     * content is centred with a maximum width to improve readability.
     */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #f7f9fb;
      color: #333;
      padding: 20px;
      /* Increase the maximum width to accommodate side‚Äëby‚Äëside code and comment panes */
      max-width: 1300px;
      margin: auto;
    }

    /* Form controls adopt a consistent height, border radius and
       light border. */
    input,
    textarea {
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
    }
    input {
      width: 300px;
    }
    textarea {
      width: 100%;
      font-family: monospace;
      resize: both;
      overflow: auto;
      background: #fff;
    }

    /* General button styling with a primary colour palette and
       transitions for hover effects.  A small border radius softens
       corners. */
    button {
      font-size: 16px;
      padding: 8px 14px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: #fff;
      transition: background-color 0.15s ease;
      display: inline-block;
    }
    button:hover {
      background-color: #0056b3;
    }

    /* Styling for a neutral button used to clear GTM injection. */
    .clear-button {
      background-color: #e2e6ea;
      color: #333;
    }
    .clear-button:hover {
      background-color: #d4dadd;
    }
    /*
       Small buttons represent secondary actions.  They have a more neutral
       colour palette compared with primary buttons and subtle hover
       feedback.  Use margin to separate them when stacked.
    */
    .small-button {
      font-size: 14px;
      padding: 6px 10px;
      background-color: #e2e6ea;
      color: #333;
    }
    .small-button:hover {
      background-color: #d4dadd;
    }
    /*
       Preset event card styling.  Each event is a card with a grey
       header bar containing the event name and action buttons.  The
       textarea aligns with the header and occupies the rest of the
       card. */
    .preset-wrapper {
      border: 1px solid #eceff3;
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
      margin-bottom: 20px;
    }
    .preset-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f5f7fa;
      border-bottom: 1px solid #eceff3;
      padding: 12px 16px;
      font-weight: 600;
    }

    /* Left side of the preset header holds the primary action and the event name. */
    .preset-header-left {
      display: flex;
      align-items: center;
    }
    .preset-header-left button {
      margin-right: 10px;
    }
    .preset-header-title {
      font-size: 17px;
      margin-left: 0;
    }
    .preset-header-actions button {
      margin-left: 10px;
    }
    .preset-wrapper textarea {
      border: none;
      border-radius: 0 0 4px 4px;
      padding: 12px 16px;
      min-height: 120px;
      resize: vertical;
      width: 100%;
      /* Ensure padding is included in the width to align with header */
      box-sizing: border-box;
    }

    /* Layout for event content: code area and comment area side by side */
    .preset-content {
      display: flex;
      /* Use explicit widths rather than gaps. */
    }
    /* Code area takes up 800px of the available width */
    .preset-content .code-area {
      flex: 0 0 800px;
    }
    /* A vertical divider between code and comment areas.  The colour matches
       the grey header used for event cards. */
    .preset-content .divider {
      flex: 0 0 50px;
      background-color: #f5f7fa;
    }
    /* Comment area takes up 450px of the available width */
    .preset-content .comment-area {
      flex: 0 0 450px;
      display: flex;
      flex-direction: column;
    }
    .comment-area textarea {
      width: 100%;
      border: 1px solid #eceff3;
      border-radius: 0 0 4px 4px;
      padding: 12px 16px;
      resize: vertical;
      /* Height will be adjusted dynamically to match the code area */
      font-size: 14px;
      font-family: sans-serif;
      background: #fff;
    }
    /* List of manually added links for each event. */
    .links-list {
      font-size: 13px;
      margin-bottom: 6px;
    }
    .links-list a {
      color: #007bff;
      text-decoration: underline;
      display: block;
    }
    /* Button to add a new link. Placed inside the comment area. */
    .add-link-btn {
      margin-bottom: 6px;
    }

    /* Individual link item with edit and delete controls */
    .link-item {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 2px;
    }
    .link-item button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
      color: #6c757d;
    }
    .link-item button:hover {
      color: #007bff;
    }

    /* Warning label for presets that are only stored in localStorage or
       have been edited locally.  This label appears next to the event
       name and uses a muted orange colour to draw attention without
       overwhelming the interface. */
    .change-warning {
      font-size: 12px;
      color: #d97706;
      margin-left: 8px;
    }

    /* Simple inline form for adding a link (URL and description) */
    .link-form {
      display: flex;
      flex-direction: column;
      margin-bottom: 6px;
      gap: 4px;
    }
    .link-form input {
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .link-form .link-form-actions {
      display: flex;
      gap: 6px;
    }

    /* Ace editor container inherits similar styling to the textarea it replaces. */
    .ace-editor-container {
      width: 100%;
      min-height: 120px;
    }
    /* Headings use a modern size/weight and extra spacing around
       sections. */
    .label {
      font-weight: 600;
      margin: 40px 0 15px;
      font-size: 28px;
    }
    /* Log output adopts a card-like style similar to presets. */
    .log {
      margin-top: 15px;
      background: #fff;
      padding: 10px;
      border: 1px solid #eceff3;
      border-radius: 4px;
      font-family: monospace;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    /*
     * Layout helpers for the top action buttons.  These classes group the three
     * preset actions (save, copy all and reset) together near the top of the
     * page and arrange them horizontally.  Each group contains the primary
     * button and its descriptive caption stacked vertically.  The flex
     * container allows the groups to sit side‚Äëby‚Äëside and wrap on narrow
     * screens.
     */
    .top-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      align-items: flex-start;
      margin: 20px 0;
    }
    .button-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    /*
     * Custom JS section styling inspired by Google Tag Manager.  The
     * section uses a card with a light header bar containing the title
     * and action buttons.  The textarea occupies the remainder of
     * the card without its own border, giving a cohesive look.
     */
    /* The playground section inherits card styles from .preset-wrapper.
       Only a larger bottom margin is applied here to separate it
       visually from the navigation and test events. */
    .custom-js-section {
      margin-bottom: 40px;
    }

    /*
     * Event navigation bar styling.  Displays a row of buttons to
     * quickly scroll to each event section.  Buttons use a neutral
     * colour palette similar to secondary actions.
     */
    .event-nav {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 20px 0;
    }
    .event-nav .nav-btn {
      background-color: #e2e6ea;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      color: #333;
      cursor: pointer;
      transition: background-color 0.15s ease;
      font-size: 14px;
    }
    .event-nav .nav-btn:hover {
      background-color: #d4dadd;
    }

    .event-nav-title {
      font-weight: 600;
      margin: 10px 0 5px;
    }

    /* Sub-label styling used below section headers for explanatory notes. */
    .sub-label {
      color: gray;
      font-size: 14px;
      margin-top: -10px;
      margin-bottom: 20px;
    }

    /* Layout for the GTM ID and local file row.  Places the GTM ID input and
       local file picker side by side on wider screens.  Allows wrapping on
       narrow screens. */
    .gtm-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    .gtm-id-group input {
      margin-right: 8px;
    }
    .local-file-group input[type="file"] {
      /* Reset margin so the file input aligns vertically with the adjacent button */
      margin: 0;
    }
    /* Align the file input and the local loader button horizontally. */
    .local-file-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    /* Ace editor uses its own themes; ensure fonts align with the rest of the app. */
    .ace_editor {
      font-family: monospace;
      font-size: 14px;
      border-radius: 0 0 4px 4px;
      border: none;
    }

    /* Allow the Ace editor container to be vertically resizable by the user. */
    .ace-editor-container {
      resize: vertical;
      overflow: auto;
    }

    /* Button state when syntax errors are present in the editor. */
    .error-button {
      background-color: #dc3545 !important;
      color: #fff !important;
    }
    .error-button:hover {
      background-color: #c82333 !important;
    }

    /* Button state when only warnings (e.g., extra spaces) are present. */
    .warn-button {
      background-color: #ffc107 !important;
      color: #212529 !important;
    }
    .warn-button:hover {
      background-color: #e0a800 !important;
    }

    /* Primary style for trim buttons when they are active.  Uses the main button
       colour to draw attention while retaining small-button sizing. */
    .primary-button {
      background-color: #007bff !important;
      color: #fff !important;
    }
    .primary-button:hover {
      background-color: #0056b3 !important;
    }

    /* Lighten the appearance of error highlights in Ace to reduce visual noise. */
    .ace_editor .ace_error {
      background-color: #fee2e2 !important;
    }
    .ace_editor .ace_gutter-cell.ace_error {
      background-color: #fee2e2 !important;
      color: #721c24 !important;
    }
    .ace_editor .ace_marker-layer .ace_error {
      background-color: #fecaca !important;
    }

    /* Lighten warning annotations (e.g., trailing whitespace) but keep them visible. */
    .ace_editor .ace_warning {
      background-color: #fff3cd !important;
    }
    .ace_editor .ace_gutter-cell.ace_warning {
      background-color: #fff3cd !important;
      color: #856404 !important;
    }
    .ace_editor .ace_marker-layer .ace_warning {
      background-color: #ffe8a1 !important;
    }

    /* Version label styling */
    .version-label {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 12px;
      color: gray;
      z-index: 1000;
    }

  </style>

  <!-- Include Ace Editor from CDN for syntax highlighting.  The CDN provides the core, mode and theme scripts. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/mode-javascript.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/theme-chrome.js"></script>
</head>
<body>
  <!-- Version label displayed in the top right corner.  This text will be populated using
       the meta tag values defined in the document head (see meta[name="app-version"]).
       When deploying a new version, update the meta tags accordingly. -->
  <div class="version-label" id="versionLabel">Version: ‚Äî</div>
  <h1>GTM Playground</h1>

  <!-- Combined row for GTM ID entry and optional local datalayer.js loader -->
  <div class="gtm-row">
    <div class="gtm-id-group">
      <!-- Input for GTM Container ID.  The explanatory text is provided via a tooltip instead of an always‚Äëvisible label. -->
      <input type="text" id="gtmId" placeholder="GTM-XXXXXXX" title="Enter your GTM Container ID" />
      <button id="gtmButton" onclick="loadGTM()">Inject GTM</button>
    </div>
    <div class="local-file-group">
      <input type="file" id="localFileInput" accept=".js" />
      <!-- A tertiary button style keeps the control subtle but aligns height with primary buttons -->
      <button class="small-button" onclick="loadLocalFile()" title="Use a local file instead of the built‚Äëin datalayer.js">Use local datalayer.js</button>
    </div>
  </div>

  <!-- Top action buttons: save, copy all and reset.  These were previously
       located beneath the presets section but have been moved here for
       quicker access.  Each button is accompanied by a short description. -->
  <div class="top-buttons">
    <div class="button-group">
      <!-- Save button with tooltip explaining its purpose. -->
      <button onclick="savePresets()" title="Save changes so they persist on reload">üíæ Save Changes to localStorage</button>
    </div>
    <div class="button-group">
      <!-- Copy all events button with tooltip in English. -->
      <button onclick="copyAllAsDataLayer()" title="Copy all events in the format used by datalayer.js">üìã Copy ALL in datalayer.js fileformat</button>
    </div>
    <div class="button-group">
      <!-- Reset button with tooltip for English help. -->
      <button onclick="resetPresets()" title="Remove saved events and changes and reload from datalayer.js on github">‚ôªÔ∏è Reset and use datalayer.js from github</button>
    </div>
  </div>


  <!-- A card where users can write arbitrary code and push it to the dataLayer.
       This section appears after the log output for quick access. -->

  <!-- Log output card.  Displays the result of running events or copying code.
       Positioned above the playground for better visibility. -->
  <div class="log" id="logOutput">Console output will appear here‚Ä¶</div>

  <hr>

  <div class="custom-js-section preset-wrapper" data-ignore-nav="true">
    <div class="preset-header-bar">
      <div class="preset-header-left">
        <button onclick="runCustom()">Push</button>
        <span class="preset-header-title">dataLayer Playground</span>
      </div>
      <div class="preset-header-actions">
        <!-- Trim spaces button is hidden via visibility to preserve layout.  It is placed first so copy buttons stay in place. -->
        <button class="small-button" id="customTrimBtn" onclick="trimCustom()" style="visibility:hidden;">Trim spaces</button>
        <!-- Button to add/save the current custom playground code as a new event in localStorage. -->
        <button class="small-button" onclick="addCustomEvent()">Save Event to localStorage</button>
        <button class="small-button" onclick="copyCustom()">Copy as dataLayer.push</button>
        <button class="small-button" onclick="copyCustomDL()">Copy as datalayer.js block</button>
      </div>
    </div>
    <!-- Hidden textarea to hold the raw code for persistence.  Ace will sync
         its value into this element on change. -->
    <textarea id="customJson" style="display:none;">// Example:
dataLayer.push({
  event: "custom_event",
  my_value: 123
});</textarea>
    <!-- Visible editor for writing custom JS.  Ace will be instantiated on this container. -->
    <div id="customEditor" class="ace-editor-container" style="height: 150px;"></div>
  </div>

  <!-- Divider after the dataLayer Playground section -->
  <hr>



  <!-- Navigation bar for quickly jumping to individual events.  Buttons
       are generated dynamically based on the loaded presets. -->
  <div class="event-nav-title">Go to event:</div>
  <div id="eventNav" class="event-nav"></div>

  <!-- Divider after the Go to event navigation -->
  <hr>

  <!-- The header for the loaded events section changes depending on whether
       presets are loaded from GitHub or from a local file.  The text is
       updated programmatically via updateLoadedEventsHeader(). -->
  <div id="loadedEventsLabel" class="label">Loaded Events</div>
  <p id="loadedEventsSubLabel" class="sub-label">(editable in <code>datalayer.js</code>)</p>
  <div id="presetsArea"></div>
  <!-- The preset action buttons have been moved to the top of the page.  The
       original buttons and descriptions were removed from this location. -->

  <script src="datalayer.js"></script>
<script>
  window.dataLayer = window.dataLayer || [];

    // Track whether the GTM container has been injected.  These variables
    // store references to the script and iframe elements so they can be
    // removed when clearing the GTM setup.
    let gtmInjected = false;
    let gtmScriptTag = null;
    let gtmIframeTag = null;

    // Holds a reference to the currently selected local file so it can be reloaded
    // without prompting the user to pick a file again.  This variable is set
    // when a file is successfully loaded via loadLocalFile().
    let currentLocalFile = null;

  // Display the static version defined in the meta tags.  To update, modify the
  // meta[name="app-version"] and meta[name="app-changelog"] values in the head.
  (function displayStaticVersion() {
    const versionEl = document.getElementById('versionLabel');
    if (!versionEl) return;
    const versionMeta = document.querySelector('meta[name="app-version"]');
    const changeMeta = document.querySelector('meta[name="app-changelog"]');
    const version = versionMeta ? versionMeta.getAttribute('content') : '';
    const desc = changeMeta ? changeMeta.getAttribute('content') : '';
    if (version) versionEl.textContent = 'Version: ' + version;
    if (desc) versionEl.title = desc;
  })();

  function loadGTM() {
    const id = document.getElementById('gtmId').value.trim();
    if (!id.match(/^GTM-[A-Z0-9]+$/i)) {
      alert('Invalid GTM ID');
      return;
    }
    // Persist the ID so it is reused on subsequent page loads
    localStorage.setItem('gtm_id', id);
    injectGTM(id);
  }

  function runCustom() {
    try {
      const editor = window.customEditor;
      const raw = editor ? editor.getValue() : document.getElementById('customJson').value;
      new Function(raw)();
      log('‚úÖ Ran custom JS');
    } catch (e) {
      log('‚ùå Error: ' + e.message);
    }
  }

  function copyCustom() {
    const editor = window.customEditor;
    const code = editor ? editor.getValue() : document.getElementById('customJson').value;
    navigator.clipboard.writeText(code).then(() => {
      log('üìã Copied custom JS');
    });
  }

  // Copy the custom JS from the playground as a datalayer.js block.  A
  // generic name is assigned since the playground code does not have
  // an explicit event name.
  function copyCustomDL() {
    const editor = window.customEditor;
    const code = editor ? editor.getValue() : document.getElementById('customJson').value;
    const name = 'custom_js';
    const fullBlock = `// ===== START ${name} =====  \n{\n  name: "${name}",\n  code: \`${code}\`\n},\n// ===== END ${name} =====`;
    navigator.clipboard.writeText(fullBlock).then(() => {
      log('üìã Copied custom JS as datalayer.js block');
    });
  }

  // Remove trailing whitespace from the custom playground code
  function trimCustom() {
    const editor = window.customEditor;
    const raw = editor ? editor.getValue() : document.getElementById('customJson').value;
    // Remove trailing spaces at line ends and normalise whitespace
    let trimmed = raw.replace(/[ \t]+$/gm, '');
    // Replace non‚Äëbreaking or zero‚Äëwidth spaces with normal spaces
    trimmed = trimmed.replace(/[\u00a0\u200b]+/g, ' ');
    // Remove extraneous commas immediately before closing braces or brackets
    trimmed = trimmed.replace(/,\s*([}\]])/g, '$1');
    if (editor) {
      editor.setValue(trimmed, -1);
    }
    document.getElementById('customJson').value = trimmed;
    log('üßπ Trailing spaces and extra punctuation removed');
  }

  /**
   * Add the current code from the custom playground as a new event in
   * the presets list.  Attempts to extract the event name from the
   * `event` property within the code; if none is found, prompts the
   * user to enter a name.  The new event is appended to the end of
   * the existing presets stored in localStorage under
   * `presets_full_js`.  After saving, the presets are reloaded and
   * the navigation bar is refreshed.
   */
  function addCustomEvent() {
    const editor = window.customEditor;
    const code = editor ? editor.getValue() : document.getElementById('customJson').value;
    // Try to extract an event name from the code
    let match = code.match(/event\s*:\s*["'`]([^"'`]+)["'`]/);
    let name = match ? match[1] : '';
    if (!name) {
      name = prompt('Enter event name for the new event:', '') || '';
      name = name.trim();
      if (!name) {
        alert('No event name provided. Aborting.');
        return;
      }
    }
    // Retrieve existing presets from localStorage or default presets
    let presets;
    const saved = localStorage.getItem('presets_full_js');
    if (saved) {
      try {
        presets = JSON.parse(saved);
        if (!Array.isArray(presets)) presets = [];
      } catch (e) {
        presets = [];
      }
    } else {
      presets = (window.gtmPresets || []).map(ev => {
        return {
          name: ev.name,
          code: ev.code,
          comment: ev.comment || '',
          links: []
        };
      });
    }
    // Append the new event
    presets.push({ name: name, code: code, comment: '', links: [] });
    localStorage.setItem('presets_full_js', JSON.stringify(presets));
    log('‚ûï Added event \'' + name + '\' to list');
    loadPresets();
  }

  // Inject the GTM container into the page by appending the script and
  // noscript iframe.  This function uses gtmInjected to prevent multiple
  // injections and updates the GTM button state accordingly.
  function injectGTM(id) {
    if (gtmInjected) return;
    // Create and append the GTM script
    gtmScriptTag = document.createElement('script');
    gtmScriptTag.src = 'https://www.googletagmanager.com/gtm.js?id=' + id;
    gtmScriptTag.async = true;
    gtmScriptTag.id = 'gtm-script';
    document.head.appendChild(gtmScriptTag);
    // Push gtm.start event to the dataLayer
    dataLayer.push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
    // Create and append the noscript iframe
    gtmIframeTag = document.createElement('iframe');
    gtmIframeTag.src = 'https://www.googletagmanager.com/ns.html?id=' + id;
    gtmIframeTag.height = 0;
    gtmIframeTag.width = 0;
    gtmIframeTag.style.display = 'none';
    gtmIframeTag.style.visibility = 'hidden';
    document.body.appendChild(gtmIframeTag);
    gtmInjected = true;
    updateGtmButtonState(true, id);
  }

  // Clear the previously injected GTM script and iframe.  Also remove the
  // stored GTM ID and reset the button state.
  function clearGTM() {
    localStorage.removeItem('gtm_id');
    if (gtmScriptTag) {
      gtmScriptTag.remove();
      gtmScriptTag = null;
    }
    if (gtmIframeTag) {
      gtmIframeTag.remove();
      gtmIframeTag = null;
    }
    gtmInjected = false;
    // Clear the input field
    const input = document.getElementById('gtmId');
    if (input) input.value = '';
    updateGtmButtonState(false);
  }

  // Update the GTM button to reflect whether a container is loaded.  When
  // loaded is true, the button becomes a neutral "Clear GTM" button; when
  // false, it reverts to the primary "Inject GTM" button.
  function updateGtmButtonState(loaded, id) {
    const btn = document.getElementById('gtmButton');
    if (!btn) return;
    if (loaded) {
      btn.textContent = 'Clear GTM';
      btn.onclick = clearGTM;
      btn.classList.add('clear-button');
    } else {
      btn.textContent = 'Inject GTM';
      btn.onclick = loadGTM;
      btn.classList.remove('clear-button');
    }
  }

  // Update the header for the loaded events section based on the source
  // of presets.  When currentLocalFile is set, the header indicates
  // that events come from a local file and includes the file name.  Otherwise,
  // it states that events are loaded from GitHub.  The sub-label text
  // remains unchanged.
  function updateLoadedEventsHeader() {
    const labelEl = document.getElementById('loadedEventsLabel');
    if (!labelEl) return;
    if (currentLocalFile) {
      labelEl.textContent = `Loaded Events from local file ${currentLocalFile.name}`;
    } else {
      labelEl.textContent = 'Loaded Events from GitHub';
    }
  }

  function log(msg) {
    document.getElementById('logOutput').textContent = msg;
    console.log(msg);
  }

  const defaultPresets = window.gtmPresets || [];
  // Track the base presets loaded from the source file (GitHub or
  // local file).  This array is used to determine whether an event
  // in localStorage has diverged from the original source (changed
  // code or comment) or is entirely new.  Initially it points at
  // the default presets from window.gtmPresets, but when a local
  // datalayer.js file is loaded the basePresets will be updated to
  // that processed list.  When the presets are reset, basePresets
  // reverts to the default presets.
  let basePresets = window.gtmPresets || [];

  function loadPresets() {
    const saved = localStorage.getItem('presets_full_js');
    const presets = saved ? JSON.parse(saved) : defaultPresets;

    const container = document.getElementById('presetsArea');
    container.innerHTML = '';

    presets.forEach((preset, i) => {
      container.appendChild(renderPreset(preset, i));
    });

    // After presets have been rendered, rebuild the navigation bar.  This
    // ensures that each event is represented by a navigation button.
    renderNavigation();

    // Update the header to indicate the source of the loaded events
    updateLoadedEventsHeader();
  }

  function renderPreset(preset, index) {
    const wrapper = document.createElement('div');
    wrapper.className = 'preset-wrapper';

    // Build a header bar containing the event title and action buttons
    const header = document.createElement('div');
    header.className = 'preset-header-bar';

    const headerLeft = document.createElement('div');
    headerLeft.className = 'preset-header-left';

    const title = document.createElement('span');
    title.className = 'preset-header-title';
    const eventName = preset.name || `custom_${index + 1}`;
    // Determine whether the event is new or modified relative to the base
    let baseEventForName = basePresets.find(ev => ev && ev.name === eventName);
    let displayName = eventName;
    if (!baseEventForName) {
      // New event created in this session/localStorage
      displayName = `${eventName} (In localStorage)`;
    } else {
      // Check if code/comment differ; reuse the changed calculation logic
      const normName = (str) => {
        if (!str) return '';
        return str
          .trim()
          .replace(/\r\n/g, '\n')
          .replace(/[ \t]+$/gm, '');
      };
      const baseCodeForName = normName(baseEventForName.code);
      const thisCodeForName = normName(preset.code);
      const baseCommentForName = normName(baseEventForName.comment || '');
      const thisCommentForName = normName(preset.comment || '');
      if (baseCodeForName !== thisCodeForName || baseCommentForName !== thisCommentForName) {
        displayName = `${eventName} (Modified)`;
      }
    }
    title.textContent = displayName;

    // Determine whether this preset has been modified relative to the
    // original source (basePresets).  A preset is considered modified
    // if it does not exist in basePresets or if the code or comment
    // differs from its counterpart.  Whitespace at the ends of lines
    // is ignored for comparison.
    let changed = false;
    do {
      const base = basePresets.find(ev => ev && ev.name === eventName);
      if (!base) {
        // New event not present in the source file
        changed = true;
        break;
      }
      // Normalise whitespace for comparison
      const norm = (str) => {
        if (!str) return '';
        return str
          .trim()
          .replace(/\r\n/g, '\n')
          .replace(/[ \t]+$/gm, '');
      };
      const baseCode = norm(base.code);
      const thisCode = norm(preset.code);
      if (baseCode !== thisCode) {
        changed = true;
        break;
      }
      const baseComment = norm(base.comment || '');
      const thisComment = norm(preset.comment || '');
      if (baseComment !== thisComment) {
        changed = true;
        break;
      }
    } while (false);

    // Primary action: push/run the event code
    const runBtn = document.createElement('button');
    runBtn.textContent = 'Push';

    // Build left part: run button followed by event name
    headerLeft.appendChild(runBtn);
    headerLeft.appendChild(title);

    // A span used to display a warning when the event differs from the
    // original source.  Create it once and toggle its visibility later.
    const warnSpan = document.createElement('span');
    warnSpan.className = 'change-warning';
    warnSpan.textContent = '(local changes)';
    warnSpan.style.display = changed ? 'inline' : 'none';
    headerLeft.appendChild(warnSpan);

    // Right part: copy as dataLayer.push and as datalayer.js block
    const actions = document.createElement('div');
    actions.className = 'preset-header-actions';

    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy as dataLayer.push';
    copyBtn.className = 'small-button';

    const copyDLBtn = document.createElement('button');
    copyDLBtn.textContent = 'Copy as datalayer.js block';
    copyDLBtn.className = 'small-button';

    // If this preset has local-only changes, visually mark the copy button
    // and add a subtle warning label to the header.  The warning
    // indicates that the current event differs from the loaded source
    // (either a new event or modified code/comment).
    if (changed) {
      copyDLBtn.classList.add('warn-button');
    }

    // Utility to trim trailing whitespace from the editor content.  This button
    // begins hidden (via visibility) to preserve layout and will be shown
    // when trailing whitespace is detected.  A primary-button class is
    // toggled on demand to emphasise its importance when active.
    const trimBtn = document.createElement('button');
    trimBtn.textContent = 'Trim spaces';
    trimBtn.className = 'small-button';
    trimBtn.style.visibility = 'hidden';


    // Insert trim button first so the copy buttons remain fixed in place
    actions.appendChild(trimBtn);
    actions.appendChild(copyBtn);
    actions.appendChild(copyDLBtn);

    // Construct header
    header.appendChild(headerLeft);
    header.appendChild(actions);

    // Hidden textarea to store the event code for persistence and localStorage
    const textarea = document.createElement('textarea');
    textarea.dataset.index = index;
    textarea.dataset.name = eventName;
    textarea.value = preset.code;
    textarea.rows = 10;
    textarea.className = 'preset-textarea';
    textarea.style.display = 'none';

    // Visible Ace editor container
    const editorDiv = document.createElement('div');
    editorDiv.id = `preset_editor_${index}`;
    editorDiv.className = 'ace-editor-container';
    editorDiv.style.height = '150px';

    // Placeholder for the editor instance
    let editorInstance;

    // Click handlers referencing the Ace editor when available
    runBtn.onclick = () => {
      try {
        const code = editorInstance ? editorInstance.getValue() : textarea.value;
        new Function(code)();
        log(`‚úÖ Executed: ${eventName}`);
      } catch (e) {
        log('‚ùå Error parsing JS: ' + e.message);
      }
    };
    copyBtn.onclick = () => {
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      navigator.clipboard.writeText(code).then(() => {
        log('üìã Copied as dataLayer.push');
      });
    };
    copyDLBtn.onclick = () => {
      const name = textarea.dataset.name || `custom_${index + 1}`;
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      // Retrieve comment from this preset's comment textarea
      const comment = commentTextarea ? commentTextarea.value : '';
      // Gather any links associated with this preset
      let links = [];
      const wrapperDiv = textarea.closest('.preset-wrapper');
      if (wrapperDiv) {
        const linkEls = wrapperDiv.querySelectorAll('.links-list a');
        links = Array.from(linkEls).map((a) => ({ url: a.getAttribute('href'), text: a.textContent }));
      }
      const linkLines = links.map((l, idx) => `  link${idx + 1}: "${l.url} (${l.text})",\n`).join('');
      const fullBlock = 
`// ===== START ${name} =====  \n{\n  name: "${name}",\n  comment: \`${comment}\`,\n${linkLines}  code: \`${code}\`\n},\n// ===== END ${name} =====`;
      navigator.clipboard.writeText(fullBlock).then(() => {
        log('üìã Copied as datalayer.js block');
      });
    };

    // Trim trailing spaces and extraneous punctuation when requested
    trimBtn.onclick = () => {
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      let trimmed = code.replace(/[ \t]+$/gm, '');
      // Replace non‚Äëbreaking or zero‚Äëwidth spaces with normal spaces
      trimmed = trimmed.replace(/[\u00a0\u200b]+/g, ' ');
      // Remove extraneous commas immediately before closing braces or brackets
      trimmed = trimmed.replace(/,\s*([}\]])/g, '$1');
      if (editorInstance) {
        editorInstance.setValue(trimmed, -1);
      }
      textarea.value = trimmed;
      log('üßπ Trailing spaces and extra punctuation removed');
    };

    wrapper.appendChild(header);
    // Create a container for the code and comment areas
    const contentDiv = document.createElement('div');
    contentDiv.className = 'preset-content';
    // Wrap the Ace editor in a code area div to control width
    const codeWrapper = document.createElement('div');
    codeWrapper.className = 'code-area';
    codeWrapper.appendChild(editorDiv);
    // Create the comment area on the right
    const commentWrapper = document.createElement('div');
    commentWrapper.className = 'comment-area';
    // Container to list added links
    const linksDiv = document.createElement('div');
    linksDiv.className = 'links-list';
    commentWrapper.appendChild(linksDiv);
    // Button to add new links
    const addLinkBtn = document.createElement('button');
    addLinkBtn.textContent = 'Add link';
    addLinkBtn.className = 'small-button add-link-btn';
    commentWrapper.appendChild(addLinkBtn);
    // Comment textarea for freeform notes
    const commentTextarea = document.createElement('textarea');
    commentTextarea.placeholder = 'Add comment‚Ä¶';
    commentTextarea.value = preset.comment || '';
    commentTextarea.dataset.index = index;
    commentWrapper.appendChild(commentTextarea);
    // Internal array to store links as objects { url, text }
    const links = [];
    // If preset has existing links (e.g., loaded from localStorage), initialise them
    if (preset.links && Array.isArray(preset.links)) {
      preset.links.forEach(l => {
        if (l && l.url) links.push({ url: l.url, text: l.text || l.url });
      });
    }
    // Helper to create a link form for adding/editing a link
    const createLinkForm = (initialUrl = '', initialText = '', onSave) => {
      addLinkBtn.style.display = 'none';
      const form = document.createElement('div');
      form.className = 'link-form';
      const urlInput = document.createElement('input');
      urlInput.type = 'text';
      urlInput.placeholder = 'URL';
      urlInput.value = initialUrl;
      const textInput = document.createElement('input');
      textInput.type = 'text';
      textInput.placeholder = 'Description (optional)';
      textInput.value = initialText;
      const actions = document.createElement('div');
      actions.className = 'link-form-actions';
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save';
      saveBtn.className = 'small-button';
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'small-button';
      actions.appendChild(saveBtn);
      actions.appendChild(cancelBtn);
      form.appendChild(urlInput);
      form.appendChild(textInput);
      form.appendChild(actions);
      commentWrapper.insertBefore(form, commentTextarea);
      // Save handler
      saveBtn.onclick = () => {
        const url = urlInput.value.trim();
        if (!url) {
          alert('Please enter a URL.');
          return;
        }
        const txt = textInput.value.trim() || url;
        onSave(url, txt);
        form.remove();
        addLinkBtn.style.display = '';
      };
      // Cancel handler
      cancelBtn.onclick = () => {
        form.remove();
        addLinkBtn.style.display = '';
      };
    };
    // Function to render links list in the UI with edit/delete controls
    const renderLinks = () => {
      linksDiv.innerHTML = '';
      if (links.length > 0) {
        linksDiv.style.display = 'block';
        links.forEach((l, idx) => {
          const item = document.createElement('div');
          item.className = 'link-item';
          const linkEl = document.createElement('a');
          linkEl.href = l.url;
          linkEl.target = '_blank';
          linkEl.rel = 'noopener noreferrer';
          linkEl.textContent = l.text || l.url;
          linkEl.title = l.url;
          item.appendChild(linkEl);
          // Edit button
          const editBtn = document.createElement('button');
          editBtn.innerHTML = '‚úèÔ∏è';
          editBtn.title = 'Edit link';
          editBtn.onclick = () => {
            createLinkForm(l.url, l.text || '', (newUrl, newText) => {
              links[idx] = { url: newUrl, text: newText || newUrl };
              renderLinks();
            });
          };
          item.appendChild(editBtn);
          // Delete button
          const delBtn = document.createElement('button');
          delBtn.innerHTML = 'üóëÔ∏è';
          delBtn.title = 'Delete link';
          delBtn.onclick = () => {
            links.splice(idx, 1);
            renderLinks();
          };
          item.appendChild(delBtn);
          linksDiv.appendChild(item);
        });
      } else {
        linksDiv.style.display = 'none';
      }
    };
    renderLinks();
    // Show the link form when the add button is clicked
    addLinkBtn.onclick = () => {
      createLinkForm('', '', (url, txt) => {
        links.push({ url: url, text: txt });
        renderLinks();
      });
    };
    // Assemble content with a divider between the code and comment areas
    contentDiv.appendChild(codeWrapper);
    const dividerEl = document.createElement('div');
    dividerEl.className = 'divider';
    contentDiv.appendChild(dividerEl);
    contentDiv.appendChild(commentWrapper);
    wrapper.appendChild(contentDiv);
    wrapper.appendChild(textarea);

    // Instantiate the Ace editor after a short delay to ensure the element exists in the DOM
    setTimeout(() => {
      if (window.ace) {
        editorInstance = ace.edit(editorDiv.id);
        editorInstance.session.setMode('ace/mode/javascript');
        editorInstance.setTheme('ace/theme/chrome');
        editorInstance.setValue(preset.code || '', -1);
        editorInstance.setOptions({
          showPrintMargin: false,
          tabSize: 2,
          useSoftTabs: true
        });
        // Sync the hidden textarea whenever the editor content changes
        editorInstance.session.on('change', () => {
          textarea.value = editorInstance.getValue();
        });

        // Set JSHint options on the worker to allow modern syntax, including trailing commas in function calls
        if (editorInstance.session.$worker) {
          editorInstance.session.$worker.call('setOptions', [{ esversion: 10 }]);
        }

        // Adjust the height of the code and comment areas based on the number of lines
        const adjustHeight = () => {
          // Determine how many lines are in the editor
          const lineCount = editorInstance.session.getLength();
          // Always display at least 10 lines.  Add one extra line beyond
          // the actual code to provide breathing room, but cap at 20 lines.
          // Add two extra blank lines for visual breathing room.  Ensure at
          // least 10 lines are shown, but cap to avoid excessive height.
          let lines = lineCount + 2;
          if (lines < 10) lines = 10;
          // Use a slightly higher cap so that visually 20 lines are shown in the Ace editor
          if (lines > 21) lines = 21;
          const lineHeight = editorInstance.renderer.lineHeight || 16;
          const newHeight = lines * lineHeight;
          // Apply height to the Ace editor container and comment textarea
          editorDiv.style.height = newHeight + 'px';
          if (commentTextarea) {
            commentTextarea.style.height = newHeight + 'px';
          }
          editorInstance.resize();
        };
        adjustHeight();
        // Recalculate height whenever the content changes
        editorInstance.session.on('change', adjustHeight);

        // Monitor annotations and content to toggle the run button colour
        // and display a trim‚Äëspaces button when trailing whitespace is present.
        const session = editorInstance.getSession();
        const updateButtonState = () => {
          // Determine if any syntax errors are present
          const anns = session.getAnnotations() || [];
          // Ace may mark some parse issues as warnings rather than errors.  We
          // consider any annotation an issue that could benefit from trimming.
          const hasError = anns.some(a => a.type === 'error');
          const hasAnyIssue = anns.length > 0;
          // Detect trailing whitespace by scanning each line of the editor contents.
          const code = editorInstance.getValue();
          const lines = code.split('\n');
          const hasTrailing = lines.some(l => /[ \t]+$/.test(l));
          // Apply visual states: red for errors, yellow for only trailing whitespace.
          runBtn.classList.toggle('error-button', hasError);
          runBtn.classList.toggle('warn-button', !hasError && hasTrailing);
          // Show the trim button whenever there is trailing whitespace or any annotation.
          if (hasTrailing || hasAnyIssue) {
            trimBtn.style.visibility = 'visible';
            // Highlight as primary only when the issue is just trailing whitespace (no syntax error).
            if (hasTrailing && anns.length === 0) {
              trimBtn.classList.add('primary-button');
            } else {
              trimBtn.classList.remove('primary-button');
            }
          } else {
            trimBtn.style.visibility = 'hidden';
            trimBtn.classList.remove('primary-button');
          }
        };
        updateButtonState();
        // Listen for changes in annotations (errors/warnings) and editor text
        session.on('changeAnnotation', updateButtonState);
        session.on('change', updateButtonState);

        // Function to evaluate whether the current event differs from the
        // base presets.  If the code or comment has been modified or if
        // the event did not exist in the original file, this will show
        // a warning label and highlight the datalayer.js copy button.
        const updateChange = () => {
          // Find the matching base event by name
          const baseEvent = basePresets.find(ev => ev && ev.name === eventName);
          let isChanged = false;
          const normalise = (str) => {
            if (!str) return '';
            return str
              .trim()
              .replace(/\r\n/g, '\n')
              .replace(/[ \t]+$/gm, '');
          };
          const currentCode = normalise(editorInstance ? editorInstance.getValue() : textarea.value);
          const currentComment = normalise(commentTextarea.value || '');
          if (!baseEvent) {
            isChanged = true;
          } else {
            const baseCode = normalise(baseEvent.code);
            const baseComment = normalise(baseEvent.comment || '');
            if (baseCode !== currentCode || baseComment !== currentComment) {
              isChanged = true;
            }
          }
          // Toggle UI elements accordingly
          if (warnSpan) {
            warnSpan.style.display = isChanged ? 'inline' : 'none';
          }
          copyDLBtn.classList.toggle('warn-button', isChanged);
        };
        // Initial evaluation
        updateChange();
        // Monitor changes to code and comment
        editorInstance.session.on('change', updateChange);
        commentTextarea.addEventListener('input', updateChange);

        // Resize the Ace editor when the container is resized by the user
        editorDiv.addEventListener('mouseup', () => {
          editorInstance.resize();
        });
      }
    }, 0);

    return wrapper;
  }


  function savePresets() {
    const all = document.querySelectorAll('.preset-textarea');
    const updated = Array.from(all).map((el) => {
      const name = el.dataset.name || '';
      const code = el.value;
      let comment = '';
      const wrapper = el.closest('.preset-wrapper');
      let links = [];
      if (wrapper) {
        const commentEl = wrapper.querySelector('.comment-area textarea');
        if (commentEl) comment = commentEl.value || '';
        // Collect any links stored in the links-list
        const linkEls = wrapper.querySelectorAll('.links-list a');
        links = Array.from(linkEls).map((a) => ({ url: a.getAttribute('href'), text: a.textContent }));
      }
      return {
        name: name,
        code: code,
        comment: comment,
        links: links
      };
    });
    localStorage.setItem('presets_full_js', JSON.stringify(updated));
    log('üíæ Presets saved to localStorage');
    loadPresets();
  }

  function resetPresets() {
    localStorage.removeItem('presets_full_js');
    log('‚ôªÔ∏è LocalStorage cleared. Reloading datalayer.js presets‚Ä¶');
    // Clear any reference to a previously loaded local file
    currentLocalFile = null;
    // Reset the local loader button back to its original state
    const localBtn = document.querySelector('.local-file-group button');
    if (localBtn) {
      localBtn.textContent = 'Use local datalayer.js';
      // Restore small-button styling so it appears neutral
      localBtn.classList.remove('primary-button');
      localBtn.classList.add('small-button');
      localBtn.title = 'Use a local file instead of the built‚Äëin datalayer.js';
    }
    // Fetch presets again from the original datalayer.js
    const fallbackPresets = window.gtmPresets || [];
    // Reset base presets to the original source
    basePresets = fallbackPresets.slice();
    const container = document.getElementById('presetsArea');
    container.innerHTML = '';
    fallbackPresets.forEach((preset, i) => {
      container.appendChild(renderPreset(preset, i));
    });
    // Update header to show that events are from GitHub
    updateLoadedEventsHeader();
  }

  // Load events from a user‚Äëselected local datalayer.js file.  The file must
  // assign an array of event definitions to either `window.gtmPresets` or
  // `window.presetEvents` with elements of the form { name: "eventName", code: "..." }.
  // When loaded successfully, the events will replace the current presets and
  // persist in localStorage under `presets_full_js`.  An informational
  // message is displayed in the log.
  function loadLocalFile() {
    const input = document.getElementById('localFileInput');
    // If a file is explicitly provided (user just chose one via the input), load that file.
    if (input && input.files && input.files.length > 0) {
      const file = input.files[0];
      loadLocalFileFromFile(file);
    } else if (currentLocalFile) {
      // If no file is chosen but we have a previously selected file, reload it.
      loadLocalFileFromFile(currentLocalFile);
    } else {
      alert('Please select a .js file first.');
    }
  }

  // Load a local datalayer.js from a File object.  Updates the global
  // currentLocalFile reference, stores the processed events in localStorage,
  // updates the local loader button text/style, and renders the presets.
  function loadLocalFileFromFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const content = e.target.result;
      try {
        const sandbox = {};
        const wrapper = new Function('window', content + '\n; return window.gtmPresets || window.presetEvents || []');
        const events = wrapper(sandbox);
        if (Array.isArray(events) && events.length > 0) {
          const processed = events.map(ev => {
            // Extract links from properties named link1, link2, etc.
            const links = [];
            Object.keys(ev).forEach((k) => {
              if (/^link\d+$/.test(k)) {
                const val = ev[k];
                if (typeof val === 'string') {
                  // Expect pattern "url (text)"
                  const m = val.match(/^(.+)\s+\((.*)\)$/);
                  if (m) {
                    links.push({ url: m[1].trim(), text: m[2].trim() });
                  } else {
                    links.push({ url: val.trim(), text: val.trim() });
                  }
                }
              }
            });
            return {
              name: ev.name,
              code: ev.code,
              comment: ev.comment || '',
              links: links
            };
          });
          localStorage.setItem('presets_full_js', JSON.stringify(processed));
          // Update base presets to reflect the contents of the loaded local file
          basePresets = processed.slice();
          log('üìÅ Loaded events from local file');
          // Remember this file so we can reload it later without asking the user
          currentLocalFile = file;
          // Update the local loader button to indicate a local file is in use
          const localBtn = document.querySelector('.local-file-group button');
          if (localBtn) {
            localBtn.textContent = `Reset to local ${file.name}`;
            // Remove previous small-button class and apply a primary style.  We
            // deliberately keep the small-button sizing so the control remains
            // consistent with the other auxiliary buttons, but apply a
            // primary-button class to colour it blue.
            localBtn.classList.remove('small-button');
            localBtn.classList.add('small-button', 'primary-button');
            localBtn.title = `Reload the locally loaded file (${file.name}) - If chnages are made it need to be selected again`;
          }
          loadPresets();
          // Persist that a local file is in use and store its name for display
          localStorage.setItem('presets_source', 'local');
          localStorage.setItem('presets_filename', file.name);
          // Update the header to reflect that presets are from a local file
          updateLoadedEventsHeader();
        } else {
          log('‚ö†Ô∏è The selected file does not define any events (gtmPresets/presetEvents).');
        }
      } catch (err) {
        log('‚ùå Failed to load local datalayer.js: ' + err.message);
      }
    };
    reader.readAsText(file);
  }
  function copyAllAsDataLayer() {
  const all = document.querySelectorAll('.preset-textarea');

  const eventBlocks = Array.from(all).map((el, i) => {
    const name = el.dataset.name || `custom_${i + 1}`;
    const code = el.value;
    // Retrieve comment and links from the preset wrapper if available
    let comment = '';
    let links = [];
    const wrapper = el.closest('.preset-wrapper');
    if (wrapper) {
      const commentEl = wrapper.querySelector('.comment-area textarea');
      if (commentEl) comment = commentEl.value || '';
      const linkEls = wrapper.querySelectorAll('.links-list a');
      links = Array.from(linkEls).map((a) => ({ url: a.getAttribute('href'), text: a.textContent }));
    }
    // Build link properties as link1, link2, etc.
    const linkLines = links.map((l, idx) => `  link${idx + 1}: "${l.url} (${l.text})",\n`).join('');
    // Construct the block with comment and link properties.  Use backticks
    // for both code and comment to preserve formatting and support special characters.
    return `// ===== START ${name} =====  \n{\n  name: "${name}",\n  comment: \`${comment}\`,\n${linkLines}  code: \`${code}\`\n},\n// ===== END ${name} =====`;
  });

  const finalCode = `const presetEvents = [\n${eventBlocks.join('\n\n')}\n];\n\nwindow.gtmPresets = presetEvents;`;

  navigator.clipboard.writeText(finalCode).then(() => {
    log('üìã All events copied as datalayer.js file');
  });
}

  /*
   * Create a URL‚Äëfriendly slug from a string.  Lowercases and
   * replaces non‚Äëalphanumeric characters with underscores.  Used to
   * generate element IDs based on event names.
   */
  function slugify(str) {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  /*
   * Build the navigation bar of event links.  Each button will scroll
   * smoothly to the corresponding event card when clicked.
   */
  function renderNavigation() {
    const nav = document.getElementById('eventNav');
    if (!nav) return;
    nav.innerHTML = '';
    const wrappers = document.querySelectorAll('.preset-wrapper');
    wrappers.forEach((wrapper) => {
      // Skip wrappers flagged to be ignored by the navigation bar
      if (wrapper.getAttribute('data-ignore-nav') === 'true') return;
      const titleEl = wrapper.querySelector('.preset-header-title');
      if (!titleEl) return;
      const name = titleEl.textContent.trim();
      const id = 'event_' + slugify(name);
      wrapper.id = id;

      const btn = document.createElement('button');
      btn.className = 'nav-btn';
      btn.textContent = name;
      btn.onclick = () => {
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      };
      nav.appendChild(btn);
    });
  }


  window.addEventListener('load', () => {
    const lastId = localStorage.getItem('gtm_id');
    if (lastId) {
      document.getElementById('gtmId').value = lastId;
      // Automatically inject the stored GTM container on page load
      injectGTM(lastId);
    }
    loadPresets();
    // Initialise the Ace editor for the custom JS playground once the DOM is ready.
    if (window.ace) {
      const customEditor = ace.edit('customEditor');
      customEditor.session.setMode('ace/mode/javascript');
      // Use a light theme to match the application's design
      customEditor.setTheme('ace/theme/chrome');
      customEditor.setValue(document.getElementById('customJson').value || '', -1);
      customEditor.session.on('change', () => {
        document.getElementById('customJson').value = customEditor.getValue();
      });
      // Hide the print margin and adjust some editor options
      customEditor.setOptions({
        showPrintMargin: false,
        tabSize: 2,
        useSoftTabs: true
      });
      // Configure the JavaScript worker to support modern syntax, including trailing commas
      const customSess = customEditor.getSession();
      if (customSess.$worker) {
        customSess.$worker.call('setOptions', [{ esversion: 10 }]);
      }
      window.customEditor = customEditor;

      // Attach state styling and trailing whitespace detection to the playground push button
      const customRunBtn = document.querySelector('.custom-js-section .preset-header-left button');
      const customTrimBtn = document.getElementById('customTrimBtn');
      if (customRunBtn && customTrimBtn) {
        const session = customEditor.getSession();
        const updatePlaygroundButton = () => {
          const anns = session.getAnnotations() || [];
          const hasError = anns.some(a => a.type === 'error');
          const hasAnyIssue = anns.length > 0;
          // Detect trailing whitespace in custom editor
          const code = customEditor.getValue();
          const lines = code.split('\n');
          const hasTrailing = lines.some(l => /[ \t]+$/.test(l));
          // Apply button styles: red for errors, yellow for warnings
          customRunBtn.classList.toggle('error-button', hasError);
          customRunBtn.classList.toggle('warn-button', !hasError && hasTrailing);
          // Show trim button whenever there is trailing whitespace or any annotation
          if (hasTrailing || hasAnyIssue) {
            customTrimBtn.style.visibility = 'visible';
            // Highlight the trim button only when the issue is just trailing whitespace
            if (hasTrailing && !hasAnyIssue) {
              customTrimBtn.classList.add('primary-button');
            } else {
              customTrimBtn.classList.remove('primary-button');
            }
          } else {
            customTrimBtn.style.visibility = 'hidden';
            customTrimBtn.classList.remove('primary-button');
          }
        };
        updatePlaygroundButton();
        session.on('changeAnnotation', updatePlaygroundButton);
        session.on('change', updatePlaygroundButton);
      }

      // Allow resizing of the custom editor and refresh layout on mouseup
      const customContainer = document.getElementById('customEditor');
      if (customContainer) {
        customContainer.addEventListener('mouseup', () => {
          customEditor.resize();
        });
      }
    }
  });
</script>
</body>
</html>
