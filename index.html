<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GTM Playground</title>
  <!-- Application version metadata.  Update these values when you commit new versions.
       app-version holds a simple version string, e.g. 1.2.3, and app-changelog holds
       a short description of what changed. -->
  <meta name="app-version" content="2.3.0">
  <meta name="app-changelog" content="Improve GTM load">
  <style>
    /*
     * Base layout styling.  A subtle background colour and modern
     * typography give the app a more contemporary feel.  The
     * content is centred with a maximum width to improve readability.
     */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #f7f9fb;
      color: #333;
      padding: 20px;
      max-width: 1000px;
      margin: auto;
    }

    /* Form controls adopt a consistent height, border radius and
       light border. */
    input,
    textarea {
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
    }
    input {
      width: 300px;
    }
    textarea {
      width: 100%;
      font-family: monospace;
      resize: both;
      overflow: auto;
      background: #fff;
    }

    /* General button styling with a primary colour palette and
       transitions for hover effects.  A small border radius softens
       corners. */
    button {
      font-size: 16px;
      padding: 8px 14px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: #fff;
      transition: background-color 0.15s ease;
      display: inline-block;
    }
    button:hover {
      background-color: #0056b3;
    }

    /* Styling for a neutral button used to clear GTM injection. */
    .clear-button {
      background-color: #e2e6ea;
      color: #333;
    }
    .clear-button:hover {
      background-color: #d4dadd;
    }
    /*
       Small buttons represent secondary actions.  They have a more neutral
       colour palette compared with primary buttons and subtle hover
       feedback.  Use margin to separate them when stacked.
    */
    .small-button {
      font-size: 14px;
      padding: 6px 10px;
      background-color: #e2e6ea;
      color: #333;
    }
    .small-button:hover {
      background-color: #d4dadd;
    }
    /*
       Preset event card styling.  Each event is a card with a grey
       header bar containing the event name and action buttons.  The
       textarea aligns with the header and occupies the rest of the
       card. */
    .preset-wrapper {
      border: 1px solid #eceff3;
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
      margin-bottom: 20px;
    }
    .preset-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f5f7fa;
      border-bottom: 1px solid #eceff3;
      padding: 12px 16px;
      font-weight: 600;
    }

    /* Left side of the preset header holds the primary action and the event name. */
    .preset-header-left {
      display: flex;
      align-items: center;
    }
    .preset-header-left button {
      margin-right: 10px;
    }
    .preset-header-title {
      font-size: 17px;
      margin-left: 0;
    }
    .preset-header-actions button {
      margin-left: 10px;
    }
    .preset-wrapper textarea {
      border: none;
      border-radius: 0 0 4px 4px;
      padding: 12px 16px;
      min-height: 120px;
      resize: vertical;
      width: 100%;
      /* Ensure padding is included in the width to align with header */
      box-sizing: border-box;
    }

    /* Ace editor container inherits similar styling to the textarea it replaces. */
    .ace-editor-container {
      width: 100%;
      min-height: 120px;
    }
    /* Headings use a modern size/weight and extra spacing around
       sections. */
    .label {
      font-weight: 600;
      margin: 40px 0 15px;
      font-size: 28px;
    }
    /* Log output adopts a card-like style similar to presets. */
    .log {
      margin-top: 15px;
      background: #fff;
      padding: 10px;
      border: 1px solid #eceff3;
      border-radius: 4px;
      font-family: monospace;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }

    /*
     * Layout helpers for the top action buttons.  These classes group the three
     * preset actions (save, copy all and reset) together near the top of the
     * page and arrange them horizontally.  Each group contains the primary
     * button and its descriptive caption stacked vertically.  The flex
     * container allows the groups to sit side‚Äëby‚Äëside and wrap on narrow
     * screens.
     */
    .top-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      align-items: flex-start;
      margin: 20px 0;
    }
    .button-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    /*
     * Custom JS section styling inspired by Google Tag Manager.  The
     * section uses a card with a light header bar containing the title
     * and action buttons.  The textarea occupies the remainder of
     * the card without its own border, giving a cohesive look.
     */
    /* The playground section inherits card styles from .preset-wrapper.
       Only a larger bottom margin is applied here to separate it
       visually from the navigation and test events. */
    .custom-js-section {
      margin-bottom: 40px;
    }

    /*
     * Event navigation bar styling.  Displays a row of buttons to
     * quickly scroll to each event section.  Buttons use a neutral
     * colour palette similar to secondary actions.
     */
    .event-nav {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 20px 0;
    }
    .event-nav .nav-btn {
      background-color: #e2e6ea;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      color: #333;
      cursor: pointer;
      transition: background-color 0.15s ease;
      font-size: 14px;
    }
    .event-nav .nav-btn:hover {
      background-color: #d4dadd;
    }

    .event-nav-title {
      font-weight: 600;
      margin: 10px 0 5px;
    }

    /* Sub-label styling used below section headers for explanatory notes. */
    .sub-label {
      color: gray;
      font-size: 14px;
      margin-top: -10px;
      margin-bottom: 20px;
    }

    /* Layout for the GTM ID and local file row.  Places the GTM ID input and
       local file picker side by side on wider screens.  Allows wrapping on
       narrow screens. */
    .gtm-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    .gtm-id-group input {
      margin-right: 8px;
    }
    .local-file-group input[type="file"] {
      /* Reset margin so the file input aligns vertically with the adjacent button */
      margin: 0;
    }
    /* Align the file input and the local loader button horizontally. */
    .local-file-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    /* Ace editor uses its own themes; ensure fonts align with the rest of the app. */
    .ace_editor {
      font-family: monospace;
      font-size: 14px;
      border-radius: 0 0 4px 4px;
      border: none;
    }

    /* Allow the Ace editor container to be vertically resizable by the user. */
    .ace-editor-container {
      resize: vertical;
      overflow: auto;
    }

    /* Button state when syntax errors are present in the editor. */
    .error-button {
      background-color: #dc3545 !important;
      color: #fff !important;
    }
    .error-button:hover {
      background-color: #c82333 !important;
    }

    /* Button state when only warnings (e.g., extra spaces) are present. */
    .warn-button {
      background-color: #ffc107 !important;
      color: #212529 !important;
    }
    .warn-button:hover {
      background-color: #e0a800 !important;
    }

    /* Primary style for trim buttons when they are active.  Uses the main button
       colour to draw attention while retaining small-button sizing. */
    .primary-button {
      background-color: #007bff !important;
      color: #fff !important;
    }
    .primary-button:hover {
      background-color: #0056b3 !important;
    }

    /* Lighten the appearance of error highlights in Ace to reduce visual noise. */
    .ace_editor .ace_error {
      background-color: #fee2e2 !important;
    }
    .ace_editor .ace_gutter-cell.ace_error {
      background-color: #fee2e2 !important;
      color: #721c24 !important;
    }
    .ace_editor .ace_marker-layer .ace_error {
      background-color: #fecaca !important;
    }

    /* Lighten warning annotations (e.g., trailing whitespace) but keep them visible. */
    .ace_editor .ace_warning {
      background-color: #fff3cd !important;
    }
    .ace_editor .ace_gutter-cell.ace_warning {
      background-color: #fff3cd !important;
      color: #856404 !important;
    }
    .ace_editor .ace_marker-layer .ace_warning {
      background-color: #ffe8a1 !important;
    }

    /* Version label styling */
    .version-label {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 12px;
      color: gray;
      z-index: 1000;
    }

  </style>

  <!-- Include Ace Editor from CDN for syntax highlighting.  The CDN provides the core, mode and theme scripts. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/mode-javascript.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/theme-chrome.js"></script>
</head>
<body>
  <!-- Version label displayed in the top right corner.  This text will be populated using
       the meta tag values defined in the document head (see meta[name="app-version"]).
       When deploying a new version, update the meta tags accordingly. -->
  <div class="version-label" id="versionLabel">Version: ‚Äî</div>
  <h1>GTM Playground</h1>

  <!-- Combined row for GTM ID entry and optional local datalayer.js loader -->
  <div class="gtm-row">
    <div class="gtm-id-group">
      <!-- Input for GTM Container ID.  The explanatory text is provided via a tooltip instead of an always‚Äëvisible label. -->
      <input type="text" id="gtmId" placeholder="GTM-XXXXXXX" title="Enter your GTM Container ID" />
      <button id="gtmButton" onclick="loadGTM()">Inject GTM</button>
    </div>
    <div class="local-file-group">
      <input type="file" id="localFileInput" accept=".js" />
      <!-- A tertiary button style keeps the control subtle but aligns height with primary buttons -->
      <button class="small-button" onclick="loadLocalFile()" title="Use a local file instead of the built‚Äëin datalayer.js">Use local datalayer.js</button>
    </div>
  </div>

  <!-- Top action buttons: save, copy all and reset.  These were previously
       located beneath the presets section but have been moved here for
       quicker access.  Each button is accompanied by a short description. -->
  <div class="top-buttons">
    <div class="button-group">
      <!-- Save button with tooltip explaining its purpose. -->
      <button onclick="savePresets()" title="Save changes so they persist on reload">üíæ Save Changes to localStorage</button>
    </div>
    <div class="button-group">
      <!-- Copy all events button with tooltip in English. -->
      <button onclick="copyAllAsDataLayer()" title="Copy all events in the format used by datalayer.js">üìã Copy ALL as datalayer.js file</button>
    </div>
    <div class="button-group">
      <!-- Reset button with tooltip for English help. -->
      <button onclick="resetPresets()" title="Remove saved events and reload from datalayer.js">‚ôªÔ∏è Reset and use datalayer.js</button>
    </div>
  </div>


  <!-- A card where users can write arbitrary code and push it to the dataLayer.
       This section appears after the log output for quick access. -->

  <!-- Log output card.  Displays the result of running events or copying code.
       Positioned above the playground for better visibility. -->
  <div class="log" id="logOutput">Console output will appear here‚Ä¶</div>

  <hr>

  <div class="custom-js-section preset-wrapper" data-ignore-nav="true">
    <div class="preset-header-bar">
      <div class="preset-header-left">
        <button onclick="runCustom()">Push</button>
        <span class="preset-header-title">dataLayer Playground</span>
      </div>
      <div class="preset-header-actions">
        <!-- Trim spaces button is hidden via visibility to preserve layout.  It is placed first so copy buttons stay in place. -->
        <button class="small-button" id="customTrimBtn" onclick="trimCustom()" style="visibility:hidden;">Trim spaces</button>
        <button class="small-button" onclick="copyCustom()">Copy as dataLayer.push</button>
        <button class="small-button" onclick="copyCustomDL()">Copy as datalayer.js block</button>
      </div>
    </div>
    <!-- Hidden textarea to hold the raw code for persistence.  Ace will sync
         its value into this element on change. -->
    <textarea id="customJson" style="display:none;">// Example:
dataLayer.push({
  event: "custom_event",
  my_value: 123
});</textarea>
    <!-- Visible editor for writing custom JS.  Ace will be instantiated on this container. -->
    <div id="customEditor" class="ace-editor-container" style="height: 150px;"></div>
  </div>

  <!-- Divider after the dataLayer Playground section -->
  <hr>



  <!-- Navigation bar for quickly jumping to individual events.  Buttons
       are generated dynamically based on the loaded presets. -->
  <div class="event-nav-title">Go to event:</div>
  <div id="eventNav" class="event-nav"></div>

  <!-- Divider after the Go to event navigation -->
  <hr>

  <!-- The header for the loaded events section changes depending on whether
       presets are loaded from GitHub or from a local file.  The text is
       updated programmatically via updateLoadedEventsHeader(). -->
  <div id="loadedEventsLabel" class="label">Loaded Events</div>
  <p id="loadedEventsSubLabel" class="sub-label">(editable in <code>datalayer.js</code>)</p>
  <div id="presetsArea"></div>
  <!-- The preset action buttons have been moved to the top of the page.  The
       original buttons and descriptions were removed from this location. -->

  <script src="datalayer.js"></script>
<script>
  window.dataLayer = window.dataLayer || [];

    // Track whether the GTM container has been injected.  These variables
    // store references to the script and iframe elements so they can be
    // removed when clearing the GTM setup.
    let gtmInjected = false;
    let gtmScriptTag = null;
    let gtmIframeTag = null;

    // Holds a reference to the currently selected local file so it can be reloaded
    // without prompting the user to pick a file again.  This variable is set
    // when a file is successfully loaded via loadLocalFile().
    let currentLocalFile = null;

  // Display the static version defined in the meta tags.  To update, modify the
  // meta[name="app-version"] and meta[name="app-changelog"] values in the head.
  (function displayStaticVersion() {
    const versionEl = document.getElementById('versionLabel');
    if (!versionEl) return;
    const versionMeta = document.querySelector('meta[name="app-version"]');
    const changeMeta = document.querySelector('meta[name="app-changelog"]');
    const version = versionMeta ? versionMeta.getAttribute('content') : '';
    const desc = changeMeta ? changeMeta.getAttribute('content') : '';
    if (version) versionEl.textContent = 'Version: ' + version;
    if (desc) versionEl.title = desc;
  })();

  function loadGTM() {
    const id = document.getElementById('gtmId').value.trim();
    if (!id.match(/^GTM-[A-Z0-9]+$/i)) {
      alert('Invalid GTM ID');
      return;
    }
    // Persist the ID so it is reused on subsequent page loads
    localStorage.setItem('gtm_id', id);
    injectGTM(id);
  }

  function runCustom() {
    try {
      const editor = window.customEditor;
      const raw = editor ? editor.getValue() : document.getElementById('customJson').value;
      new Function(raw)();
      log('‚úÖ Ran custom JS');
    } catch (e) {
      log('‚ùå Error: ' + e.message);
    }
  }

  function copyCustom() {
    const editor = window.customEditor;
    const code = editor ? editor.getValue() : document.getElementById('customJson').value;
    navigator.clipboard.writeText(code).then(() => {
      log('üìã Copied custom JS');
    });
  }

  // Copy the custom JS from the playground as a datalayer.js block.  A
  // generic name is assigned since the playground code does not have
  // an explicit event name.
  function copyCustomDL() {
    const editor = window.customEditor;
    const code = editor ? editor.getValue() : document.getElementById('customJson').value;
    const name = 'custom_js';
    const fullBlock = `// ===== START ${name} =====  \n{\n  name: "${name}",\n  code: \`${code}\`\n},\n// ===== END ${name} =====`;
    navigator.clipboard.writeText(fullBlock).then(() => {
      log('üìã Copied custom JS as datalayer.js block');
    });
  }

  // Remove trailing whitespace from the custom playground code
  function trimCustom() {
    const editor = window.customEditor;
    const raw = editor ? editor.getValue() : document.getElementById('customJson').value;
    // Remove trailing spaces at line ends and normalise whitespace
    let trimmed = raw.replace(/[ \t]+$/gm, '');
    // Replace non‚Äëbreaking or zero‚Äëwidth spaces with normal spaces
    trimmed = trimmed.replace(/[\u00a0\u200b]+/g, ' ');
    // Remove extraneous commas immediately before closing braces or brackets
    trimmed = trimmed.replace(/,\s*([}\]])/g, '$1');
    if (editor) {
      editor.setValue(trimmed, -1);
    }
    document.getElementById('customJson').value = trimmed;
    log('üßπ Trailing spaces and extra punctuation removed');
  }

  // Inject the GTM container into the page by appending the script and
  // noscript iframe.  This function uses gtmInjected to prevent multiple
  // injections and updates the GTM button state accordingly.
  function injectGTM(id) {
    if (gtmInjected) return;
    // Create and append the GTM script
    gtmScriptTag = document.createElement('script');
    gtmScriptTag.src = 'https://www.googletagmanager.com/gtm.js?id=' + id;
    gtmScriptTag.async = true;
    gtmScriptTag.id = 'gtm-script';
    document.head.appendChild(gtmScriptTag);
    // Push gtm.start event to the dataLayer
    dataLayer.push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
    // Create and append the noscript iframe
    gtmIframeTag = document.createElement('iframe');
    gtmIframeTag.src = 'https://www.googletagmanager.com/ns.html?id=' + id;
    gtmIframeTag.height = 0;
    gtmIframeTag.width = 0;
    gtmIframeTag.style.display = 'none';
    gtmIframeTag.style.visibility = 'hidden';
    document.body.appendChild(gtmIframeTag);
    gtmInjected = true;
    updateGtmButtonState(true, id);
  }

  // Clear the previously injected GTM script and iframe.  Also remove the
  // stored GTM ID and reset the button state.
  function clearGTM() {
    localStorage.removeItem('gtm_id');
    if (gtmScriptTag) {
      gtmScriptTag.remove();
      gtmScriptTag = null;
    }
    if (gtmIframeTag) {
      gtmIframeTag.remove();
      gtmIframeTag = null;
    }
    gtmInjected = false;
    // Clear the input field
    const input = document.getElementById('gtmId');
    if (input) input.value = '';
    updateGtmButtonState(false);
  }

  // Update the GTM button to reflect whether a container is loaded.  When
  // loaded is true, the button becomes a neutral "Clear GTM" button; when
  // false, it reverts to the primary "Inject GTM" button.
  function updateGtmButtonState(loaded, id) {
    const btn = document.getElementById('gtmButton');
    if (!btn) return;
    if (loaded) {
      btn.textContent = 'Clear GTM';
      btn.onclick = clearGTM;
      btn.classList.add('clear-button');
    } else {
      btn.textContent = 'Inject GTM';
      btn.onclick = loadGTM;
      btn.classList.remove('clear-button');
    }
  }

  // Update the header for the loaded events section based on the source
  // of presets.  When currentLocalFile is set, the header indicates
  // that events come from a local file and includes the file name.  Otherwise,
  // it states that events are loaded from GitHub.  The sub-label text
  // remains unchanged.
  function updateLoadedEventsHeader() {
    const labelEl = document.getElementById('loadedEventsLabel');
    if (!labelEl) return;
    if (currentLocalFile) {
      labelEl.textContent = `Loaded Events from local file ${currentLocalFile.name}`;
    } else {
      labelEl.textContent = 'Loaded Events from GitHub';
    }
  }

  function log(msg) {
    document.getElementById('logOutput').textContent = msg;
    console.log(msg);
  }

  const defaultPresets = window.gtmPresets || [];

  function loadPresets() {
    const saved = localStorage.getItem('presets_full_js');
    const presets = saved ? JSON.parse(saved) : defaultPresets;

    const container = document.getElementById('presetsArea');
    container.innerHTML = '';

    presets.forEach((preset, i) => {
      container.appendChild(renderPreset(preset, i));
    });

    // After presets have been rendered, rebuild the navigation bar.  This
    // ensures that each event is represented by a navigation button.
    renderNavigation();

    // Update the header to indicate the source of the loaded events
    updateLoadedEventsHeader();
  }

  function renderPreset(preset, index) {
    const wrapper = document.createElement('div');
    wrapper.className = 'preset-wrapper';

    // Build a header bar containing the event title and action buttons
    const header = document.createElement('div');
    header.className = 'preset-header-bar';

    const headerLeft = document.createElement('div');
    headerLeft.className = 'preset-header-left';

    const title = document.createElement('span');
    title.className = 'preset-header-title';
    const eventName = preset.name || `custom_${index + 1}`;
    title.textContent = eventName;

    // Primary action: push/run the event code
    const runBtn = document.createElement('button');
    runBtn.textContent = 'Push';

    // Build left part: run button followed by event name
    headerLeft.appendChild(runBtn);
    headerLeft.appendChild(title);

    // Right part: copy as dataLayer.push and as datalayer.js block
    const actions = document.createElement('div');
    actions.className = 'preset-header-actions';

    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy as dataLayer.push';
    copyBtn.className = 'small-button';

    const copyDLBtn = document.createElement('button');
    copyDLBtn.textContent = 'Copy as datalayer.js block';
    copyDLBtn.className = 'small-button';

    // Utility to trim trailing whitespace from the editor content.  This button
    // begins hidden (via visibility) to preserve layout and will be shown
    // when trailing whitespace is detected.  A primary-button class is
    // toggled on demand to emphasise its importance when active.
    const trimBtn = document.createElement('button');
    trimBtn.textContent = 'Trim spaces';
    trimBtn.className = 'small-button';
    trimBtn.style.visibility = 'hidden';


    // Insert trim button first so the copy buttons remain fixed in place
    actions.appendChild(trimBtn);
    actions.appendChild(copyBtn);
    actions.appendChild(copyDLBtn);

    // Construct header
    header.appendChild(headerLeft);
    header.appendChild(actions);

    // Hidden textarea to store the event code for persistence and localStorage
    const textarea = document.createElement('textarea');
    textarea.dataset.index = index;
    textarea.dataset.name = eventName;
    textarea.value = preset.code;
    textarea.rows = 10;
    textarea.className = 'preset-textarea';
    textarea.style.display = 'none';

    // Visible Ace editor container
    const editorDiv = document.createElement('div');
    editorDiv.id = `preset_editor_${index}`;
    editorDiv.className = 'ace-editor-container';
    editorDiv.style.height = '150px';

    // Placeholder for the editor instance
    let editorInstance;

    // Click handlers referencing the Ace editor when available
    runBtn.onclick = () => {
      try {
        const code = editorInstance ? editorInstance.getValue() : textarea.value;
        new Function(code)();
        log(`‚úÖ Executed: ${eventName}`);
      } catch (e) {
        log('‚ùå Error parsing JS: ' + e.message);
      }
    };
    copyBtn.onclick = () => {
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      navigator.clipboard.writeText(code).then(() => {
        log('üìã Copied as dataLayer.push');
      });
    };
    copyDLBtn.onclick = () => {
      const name = textarea.dataset.name || `custom_${index + 1}`;
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      const fullBlock = 
`// ===== START ${name} =====  \n{\n  name: "${name}",\n  code: \`${code}\`\n},\n// ===== END ${name} =====`;
      navigator.clipboard.writeText(fullBlock).then(() => {
        log('üìã Copied as datalayer.js block');
      });
    };

    // Trim trailing spaces and extraneous punctuation when requested
    trimBtn.onclick = () => {
      const code = editorInstance ? editorInstance.getValue() : textarea.value;
      let trimmed = code.replace(/[ \t]+$/gm, '');
      // Replace non‚Äëbreaking or zero‚Äëwidth spaces with normal spaces
      trimmed = trimmed.replace(/[\u00a0\u200b]+/g, ' ');
      // Remove extraneous commas immediately before closing braces or brackets
      trimmed = trimmed.replace(/,\s*([}\]])/g, '$1');
      if (editorInstance) {
        editorInstance.setValue(trimmed, -1);
      }
      textarea.value = trimmed;
      log('üßπ Trailing spaces and extra punctuation removed');
    };

    wrapper.appendChild(header);
    wrapper.appendChild(editorDiv);
    wrapper.appendChild(textarea);

    // Instantiate the Ace editor after a short delay to ensure the element exists in the DOM
    setTimeout(() => {
      if (window.ace) {
        editorInstance = ace.edit(editorDiv.id);
        editorInstance.session.setMode('ace/mode/javascript');
        editorInstance.setTheme('ace/theme/chrome');
        editorInstance.setValue(preset.code || '', -1);
        editorInstance.setOptions({
          showPrintMargin: false,
          tabSize: 2,
          useSoftTabs: true
        });
        // Sync the hidden textarea whenever the editor content changes
        editorInstance.session.on('change', () => {
          textarea.value = editorInstance.getValue();
        });

        // Set JSHint options on the worker to allow modern syntax, including trailing commas in function calls
        if (editorInstance.session.$worker) {
          editorInstance.session.$worker.call('setOptions', [{ esversion: 10 }]);
        }

        // Monitor annotations and content to toggle the run button colour
        // and display a trim‚Äëspaces button when trailing whitespace is present.
        const session = editorInstance.getSession();
        const updateButtonState = () => {
          // Determine if any syntax errors are present
          const anns = session.getAnnotations() || [];
          // Ace may mark some parse issues as warnings rather than errors.  We
          // consider any annotation an issue that could benefit from trimming.
          const hasError = anns.some(a => a.type === 'error');
          const hasAnyIssue = anns.length > 0;
          // Detect trailing whitespace by scanning each line of the editor contents.
          const code = editorInstance.getValue();
          const lines = code.split('\n');
          const hasTrailing = lines.some(l => /[ \t]+$/.test(l));
          // Apply visual states: red for errors, yellow for only trailing whitespace.
          runBtn.classList.toggle('error-button', hasError);
          runBtn.classList.toggle('warn-button', !hasError && hasTrailing);
          // Show the trim button whenever there is trailing whitespace or any annotation.
          if (hasTrailing || hasAnyIssue) {
            trimBtn.style.visibility = 'visible';
            // Highlight as primary only when the issue is just trailing whitespace (no syntax error).
            if (hasTrailing && anns.length === 0) {
              trimBtn.classList.add('primary-button');
            } else {
              trimBtn.classList.remove('primary-button');
            }
          } else {
            trimBtn.style.visibility = 'hidden';
            trimBtn.classList.remove('primary-button');
          }
        };
        updateButtonState();
        // Listen for changes in annotations (errors/warnings) and editor text
        session.on('changeAnnotation', updateButtonState);
        session.on('change', updateButtonState);

        // Resize the Ace editor when the container is resized by the user
        editorDiv.addEventListener('mouseup', () => {
          editorInstance.resize();
        });
      }
    }, 0);

    return wrapper;
  }


  function savePresets() {
    const all = document.querySelectorAll('.preset-textarea');
    const updated = Array.from(all).map((el) => {
      // Use the dataset attribute on the textarea to determine the
      // event name rather than parsing from a header.
      const name = el.dataset.name || '';
      return {
        name: name,
        code: el.value
      };
    });
    localStorage.setItem('presets_full_js', JSON.stringify(updated));
    log('üíæ Presets saved to localStorage');
    loadPresets();
  }

  function resetPresets() {
    localStorage.removeItem('presets_full_js');
    log('‚ôªÔ∏è LocalStorage cleared. Reloading datalayer.js presets‚Ä¶');
    // Clear any reference to a previously loaded local file
    currentLocalFile = null;
    // Reset the local loader button back to its original state
    const localBtn = document.querySelector('.local-file-group button');
    if (localBtn) {
      localBtn.textContent = 'Use local datalayer.js';
      // Restore small-button styling so it appears neutral
      localBtn.classList.remove('primary-button');
      localBtn.classList.add('small-button');
      localBtn.title = 'Use a local file instead of the built‚Äëin datalayer.js';
    }
    // Fetch presets again from the original datalayer.js
    const fallbackPresets = window.gtmPresets || [];
    const container = document.getElementById('presetsArea');
    container.innerHTML = '';
    fallbackPresets.forEach((preset, i) => {
      container.appendChild(renderPreset(preset, i));
    });
    // Update header to show that events are from GitHub
    updateLoadedEventsHeader();
  }

  // Load events from a user‚Äëselected local datalayer.js file.  The file must
  // assign an array of event definitions to either `window.gtmPresets` or
  // `window.presetEvents` with elements of the form { name: "eventName", code: "..." }.
  // When loaded successfully, the events will replace the current presets and
  // persist in localStorage under `presets_full_js`.  An informational
  // message is displayed in the log.
  function loadLocalFile() {
    const input = document.getElementById('localFileInput');
    // If a file is explicitly provided (user just chose one via the input), load that file.
    if (input && input.files && input.files.length > 0) {
      const file = input.files[0];
      loadLocalFileFromFile(file);
    } else if (currentLocalFile) {
      // If no file is chosen but we have a previously selected file, reload it.
      loadLocalFileFromFile(currentLocalFile);
    } else {
      alert('Please select a .js file first.');
    }
  }

  // Load a local datalayer.js from a File object.  Updates the global
  // currentLocalFile reference, stores the processed events in localStorage,
  // updates the local loader button text/style, and renders the presets.
  function loadLocalFileFromFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const content = e.target.result;
      try {
        const sandbox = {};
        const wrapper = new Function('window', content + '\n; return window.gtmPresets || window.presetEvents || []');
        const events = wrapper(sandbox);
        if (Array.isArray(events) && events.length > 0) {
          const processed = events.map(ev => ({ name: ev.name, code: ev.code }));
          localStorage.setItem('presets_full_js', JSON.stringify(processed));
          log('üìÅ Loaded events from local file');
          // Remember this file so we can reload it later without asking the user
          currentLocalFile = file;
          // Update the local loader button to indicate a local file is in use
          const localBtn = document.querySelector('.local-file-group button');
          if (localBtn) {
            localBtn.textContent = `Reload local ${file.name}`;
            // Remove previous small-button class and apply a primary style.  We
            // deliberately keep the small-button sizing so the control remains
            // consistent with the other auxiliary buttons, but apply a
            // primary-button class to colour it blue.
            localBtn.classList.remove('small-button');
            localBtn.classList.add('small-button', 'primary-button');
            localBtn.title = `Reload the locally loaded file (${file.name})`;
          }
          loadPresets();
          // Update the header to reflect that presets are from a local file
          updateLoadedEventsHeader();
        } else {
          log('‚ö†Ô∏è The selected file does not define any events (gtmPresets/presetEvents).');
        }
      } catch (err) {
        log('‚ùå Failed to load local datalayer.js: ' + err.message);
      }
    };
    reader.readAsText(file);
  }
  function copyAllAsDataLayer() {
  const all = document.querySelectorAll('.preset-textarea');

  const eventBlocks = Array.from(all).map((el, i) => {
    const name = el.dataset.name || `custom_${i + 1}`;
    const code = el.value;

    return `// ===== START ${name} =====  
{
  name: "${name}",
  code: \`${code}\`
},
// ===== END ${name} =====`;
  });

  const finalCode = `const presetEvents = [\n${eventBlocks.join('\n\n')}\n];\n\nwindow.gtmPresets = presetEvents;`;

  navigator.clipboard.writeText(finalCode).then(() => {
    log('üìã All events copied as datalayer.js file');
  });
}

  /*
   * Create a URL‚Äëfriendly slug from a string.  Lowercases and
   * replaces non‚Äëalphanumeric characters with underscores.  Used to
   * generate element IDs based on event names.
   */
  function slugify(str) {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  /*
   * Build the navigation bar of event links.  Each button will scroll
   * smoothly to the corresponding event card when clicked.
   */
  function renderNavigation() {
    const nav = document.getElementById('eventNav');
    if (!nav) return;
    nav.innerHTML = '';
    const wrappers = document.querySelectorAll('.preset-wrapper');
    wrappers.forEach((wrapper) => {
      // Skip wrappers flagged to be ignored by the navigation bar
      if (wrapper.getAttribute('data-ignore-nav') === 'true') return;
      const titleEl = wrapper.querySelector('.preset-header-title');
      if (!titleEl) return;
      const name = titleEl.textContent.trim();
      const id = 'event_' + slugify(name);
      wrapper.id = id;

      const btn = document.createElement('button');
      btn.className = 'nav-btn';
      btn.textContent = name;
      btn.onclick = () => {
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      };
      nav.appendChild(btn);
    });
  }


  window.addEventListener('load', () => {
    const lastId = localStorage.getItem('gtm_id');
    if (lastId) {
      document.getElementById('gtmId').value = lastId;
      // Automatically inject the stored GTM container on page load
      injectGTM(lastId);
    }
    loadPresets();
    // Initialise the Ace editor for the custom JS playground once the DOM is ready.
    if (window.ace) {
      const customEditor = ace.edit('customEditor');
      customEditor.session.setMode('ace/mode/javascript');
      // Use a light theme to match the application's design
      customEditor.setTheme('ace/theme/chrome');
      customEditor.setValue(document.getElementById('customJson').value || '', -1);
      customEditor.session.on('change', () => {
        document.getElementById('customJson').value = customEditor.getValue();
      });
      // Hide the print margin and adjust some editor options
      customEditor.setOptions({
        showPrintMargin: false,
        tabSize: 2,
        useSoftTabs: true
      });
      // Configure the JavaScript worker to support modern syntax, including trailing commas
      const customSess = customEditor.getSession();
      if (customSess.$worker) {
        customSess.$worker.call('setOptions', [{ esversion: 10 }]);
      }
      window.customEditor = customEditor;

      // Attach state styling and trailing whitespace detection to the playground push button
      const customRunBtn = document.querySelector('.custom-js-section .preset-header-left button');
      const customTrimBtn = document.getElementById('customTrimBtn');
      if (customRunBtn && customTrimBtn) {
        const session = customEditor.getSession();
        const updatePlaygroundButton = () => {
          const anns = session.getAnnotations() || [];
          const hasError = anns.some(a => a.type === 'error');
          const hasAnyIssue = anns.length > 0;
          // Detect trailing whitespace in custom editor
          const code = customEditor.getValue();
          const lines = code.split('\n');
          const hasTrailing = lines.some(l => /[ \t]+$/.test(l));
          // Apply button styles: red for errors, yellow for warnings
          customRunBtn.classList.toggle('error-button', hasError);
          customRunBtn.classList.toggle('warn-button', !hasError && hasTrailing);
          // Show trim button whenever there is trailing whitespace or any annotation
          if (hasTrailing || hasAnyIssue) {
            customTrimBtn.style.visibility = 'visible';
            // Highlight the trim button only when the issue is just trailing whitespace
            if (hasTrailing && !hasAnyIssue) {
              customTrimBtn.classList.add('primary-button');
            } else {
              customTrimBtn.classList.remove('primary-button');
            }
          } else {
            customTrimBtn.style.visibility = 'hidden';
            customTrimBtn.classList.remove('primary-button');
          }
        };
        updatePlaygroundButton();
        session.on('changeAnnotation', updatePlaygroundButton);
        session.on('change', updatePlaygroundButton);
      }

      // Allow resizing of the custom editor and refresh layout on mouseup
      const customContainer = document.getElementById('customEditor');
      if (customContainer) {
        customContainer.addEventListener('mouseup', () => {
          customEditor.resize();
        });
      }
    }
  });
</script>
</body>
</html>



